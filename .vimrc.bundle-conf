set exrc
set secure

" color theme
colorscheme gruvbox

let mapleader = ','    " remap leader key to ,
let maplocalleader = '\'


set wildignore+=cache,build,log,logs,.gems,__pycache__,.DS_Store,.coverage,htmlcov,coverage,tmp,node_modules
set wildignore+=*.pyc,*.o,*.obj,*.swp,*.class
set spelllang=es_es,en_us
set complete+=kspell


""""""""""""""""""""""""""""""""""""""
""""        Keymaps               """"
""""""""""""""""""""""""""""""""""""""
map <F10> :bdelete<CR>       " close current buffer

" cycle between buffers
map <C-Left> <ESC>:bprev!<CR>
map <C-Right> <ESC>:bnext!<CR>


" open tag under cursor in new tab
nmap <C-Enter> <C-w><C-]><C-w>T

" Easy align shortcuts
xmap <Leader>a <Plug>(EasyAlign)
nmap <Leader>a <Plug>(EasyAlign)

" Swap arguments
nmap sh :SidewaysJumpLeft<CR>
nmap sl :SidewaysJumpRight<CR>
nmap sH :SidewaysLeft<CR>
nmap sL :SidewaysRight<CR>

""""""""""""""""""""""""""""""""""""""
""""        Auto commands         """"
""""""""""""""""""""""""""""""""""""""
" file warmups
autocmd BufNewFile *.go  s-^-package main\r\rimport "fmt"\r\rfunc main() {\r\r}-
autocmd BufNewFile *.sh  s-^-#!/bin/bash\r\r-
autocmd BufNewFile *.c   s-^-#include <stdio.h>\r\rint main(int argc, char** argv) {\r\treturn 0;\r}-
autocmd BufNewFile *.php s-^-<?php\r\r-

" Jinja2 syntax colors
autocmd BufRead *.j2,*.twig set filetype=jinja


" view special characters
autocmd BufRead * set list
autocmd BufRead * set listchars=tab:·\ 
autocmd BufRead * set listchars=tab:·\ ,eol:¬

" Remember last location in file
au BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$")
    \| exe "normal g'\"" | endif

" nicer comments
autocmd BufNewFile,BufRead *.h,*.php set comments=s:/**,mb:*,ex:*/


" limeligth comments
autocmd! User GoyoEnter Limelight
autocmd! User GoyoLeave Limelight!

" Magically build interim directories if necessary
function! AskQuit (msg, options, quit_option)
  if confirm(a:msg, a:options) == a:quit_option
      exit
  endif
endfunction

function! EnsureDirExists ()
  let required_dir = expand("%:h")
  if !isdirectory(required_dir)
    call AskQuit("Parent directory '" . required_dir . "' doesn't exist.",
         \ "&Create it\nor &Quit?", 2)

    try
      call mkdir( required_dir, 'p' )
      catch
       call AskQuit("Can't create '" . required_dir . "'",
          \ "&Quit\nor &Continue anyway?", 1)
      endtry
  endif
endfunction

augroup AutoMkdir
  autocmd!
  autocmd BufNewFile * :call EnsureDirExists()
augroup END


" Jenkinsfiles
autocmd BufNewFile,BufRead Jenkinsfile setf groovy

" Python tweaks
augroup filetype_python
  autocmd!
  autocmd FileType python set cursorcolumn
augroup END

" Text file tweaks
augroup filetype_text
  autocmd!
  autocmd FileType text,tex,markdown,vimwiki set textwidth=80
  autocmd FileType text,tex,markdown,vimwiki setlocal spell
  autocmd FileType gitcommit setlocal spell
augroup END

""""""""""""""""""""""""""""""""""""""
""""        Plugin config         """"
""""""""""""""""""""""""""""""""""""""

" NERDTree
let g:nerdtree_show_git_status=1
let NERDTreeRespectWildIgnore=1


" TagBar
map <F2> :TagbarToggle<CR>
let g:tagbar_iconchars = ['▾', '▸']
let g:tagbar_foldlevel = 1
let g:tagbar_autofocus = 1


" Ack
let g:ack_autofold_results = 1

" DelimitMate
let delimitMate_smart_quotes = 1

" FZF
let g:fzf_history_dir = $HOME.'/.cache/fzf'

nmap <leader>f :Files<CR>
nmap <leader>F :GFiles<CR>
nmap <leader>b :Buffers<CR>
nmap <leader>s :Ag<CR>
nmap <leader>t :Tags<CR>
nmap <leader>c :Commits<CR>
nmap <leader>C :BCommits<CR>

" Vim airline
let g:airline_powerline_fonts = 1

if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif

let g:airline_symbols.colnr = '℅'

" Lens / Animate
let g:lens#disabled_filetypes = ['nerdtree', 'fzf', 'defx', 'vundle', '', 'tagbar', 'diff', 'NERD_tree_1', '[ No Name]', 'quickfix']
let g:lens#width_resize_max = 120
let g:lens#width_resize_max = 80

" cmake
let g:cmake_build_dir_location = './build'

function! CppFileToggle()
  let file_path = expand("%")
  let file_name = expand("%<")
  let extension = split(file_path, '\.')[-1] " '\.' is how you really split on dot
  let err_msg = "There is no file "

  if extension == "cpp"
    let next_file = join([file_name, ".h"], "")

    if filereadable(next_file)
      :e %<.h
    else
      echo join([err_msg, next_file], "")
    endif
  elseif extension == "h"
    let next_file = join([file_name, ".cpp"], "")

    if filereadable(next_file)
      :e %<.cpp
    else
      echo join([err_msg, next_file], "")
    endif
  endif
endfunction

augroup filetype_cpp
  autocmd!
  au BufNewFile,BufRead *.cpp,*.h,*.cc,*.c nnoremap <leader>b :CMakeBuild<CR>
  au BufNewFile,BufRead *.cpp,*.h,*.cc,*.c nnoremap <leader>q :CMakeClose<CR>
  au BufNewFile,BufRead *.cpp,*.h,*.cc,*.c nnoremap <leader>g :CMakeGenerate<CR>
  au BufNewFile,BufRead *.cpp,*.h          nnoremap <F3>      :call CppFileToggle()<CR>
augroup END

" vimwiki
let wiki = {}
let wiki.path = '~/Documents/Wiki'
let wiki.syntax = 'markdown'
let wiki.ext = '.md'
let wiki.nested_syntaxes = {
  \ 'python': 'python',
  \ 'c++': 'cpp',
  \ 'ruby': 'ruby',
  \ 'crystal': 'crystal',
  \ 'rust': 'rust',
  \}
let g:vimwiki_list = [wiki]

augroup ft_vimwiki
  au!

  au BufRead,BufNewFile *.wiki set filetype=vimwiki

  " Automatically update diary links.
  au BufEnter diary.md :VimwikiDiaryGenerateLinks
  au BufEnter diary.wiki :VimwikiDiaryGenerateLinks

  " Automatically generate a header for new wiki pages.
  " NOTE: Waiting for g:vimwiki_auto_header to get added. Think it's still in the dev branch.
  " SOURCE: https://github.com/vimwiki/vimwiki/issues/245
  au BufNewFile *.wiki :r! echo = %:t:r =
  au BufNewFile *.wiki :norm kddo

  au FileType vimwiki setlocal textwidth=80

  " Prevent remapping <CR> so i can interact with an open OmniCompletion popup:
  " SOURCE: https://github.com/vimwiki/vimwiki/blob/master/doc/vimwiki.txt#L1491
  " SOURCE: https://github.com/vimwiki/vimwiki/issues/283
  au FileType vimwiki inoremap <silent> <buffer> <expr> <CR>   pumvisible() ? "\<CR>"   : "<Esc>:VimwikiReturn 1 5<CR>"
  au FileType vimwiki inoremap <silent> <buffer> <expr> <S-CR> pumvisible() ? "\<S-CR>" : "<Esc>:VimwikiReturn 2 2<CR>"
augroup END


" deoplete
let g:deoplete#enable_at_startup = 1
call deoplete#custom#option({
\ 'num_processes': 2,
\ 'on_insert_enter': v:false,
\ })
set completeopt+=noinsert

" LSP
let g:lsp_diagnostics_enabled = 1
let g:lsp_diagnostics_echo_cursor = 1

" --- LSP for python
if executable('pyls')
  let g:jedi#popup_select_first = 0
  let g:jedi#auto_vim_configuration = 1
  let g:jedi#completions_enabled = 1
  let g:jedi#show_call_signatures = "2"
  let g:jedi#smart_auto_mappings = 1

  au FileType python setlocal completeopt-=preview

  let s:pylsp_config = {'pylsp': {'plugins': {
    \   'autopep8': {
    \     'enabled': v:false,
    \   },
    \   'pycodestyle': {'enabled': v:true},
    \   'pydocstyle': {'enabled': v:false},
    \   'pylint': {'enabled': v:true},
    \   'pyflakes': {'enabled': v:true},
    \   'flake8': {'enabled': v:true},
    \   'black': {'enabled': v:true},
    \   'jedi_definition': {
    \     'follow_imports': v:true,
    \     'follow_builtin_imports': v:true,
    \   },
    \ }}}

 "  \   'pyls_mypy': {
 "  \     'enabled': v:true,
 "  \     'live_mode': v:true,
 "  \   },

  au User lsp_setup call lsp#register_server({
      \ 'name': 'pylsp',
      \ "cmd": ["python", "-m", "pyls", "--check-parent-process"],
      \ 'allowlist': ['python'],
      \ 'workspace_config': s:pylsp_config
      \ })
endif

" --- LSP for C++
if executable('clangd')
  au User lsp_setup call lsp#register_server({
    \ 'name': 'clangd',
    \ 'cmd': {server_info->['clangd',
    \                       '--background-index',
    \                       '--all-scopes-completion',
    \                       '--clang-tidy',
    \                       '--completion-style=detailed',
    \                       '--header-insertion-decorators',
    \                       '--header-insertion=never',
    \                       '--limit-results=250',
    \                       '-j=2',
    \                       '--pch-storage=memory']},
    \ 'whitelist': ['c', 'cpp', 'objc', 'objcpp'],
    \ })
endif

" --- LSP for Ruby
if executable('solargraph')
  " gem install solargraph
  au User lsp_setup call lsp#register_server({
    \ 'name': 'solargraph',
    \ 'cmd': {server_info->[&shell, &shellcmdflag, 'solargraph stdio']},
    \ 'initialization_options': {"diagnostics": "true"},
    \ 'whitelist': ['ruby'],
  \})
endif

function! s:on_lsp_buffer_enabled() abort
  setlocal omnifunc=lsp#complete
  setlocal signcolumn=yes
  if exists('+tagfunc') | setlocal tagfunc=lsp#tagfunc | endif
  nmap <buffer> gd <plug>(lsp-definition)
  nmap <buffer> gs <plug>(lsp-document-symbol-search)
  nmap <buffer> gS <plug>(lsp-workspace-symbol-search)
  nmap <buffer> gr <plug>(lsp-references)
  nmap <buffer> gi <plug>(lsp-implementation)
  nmap <buffer> gD <plug>(lsp-type-definition)
  nmap <buffer> <leader>rn <plug>(lsp-rename)
  nmap <buffer> [g <plug>(lsp-previous-diagnostic)
  nmap <buffer> ]g <plug>(lsp-next-diagnostic)
  nmap <buffer> K <plug>(lsp-hover)
  inoremap <buffer> <expr><c-f> lsp#scroll(+4)
  inoremap <buffer> <expr><c-d> lsp#scroll(-4)

  let g:lsp_format_sync_timeout = 1000
  autocmd! BufWritePre *.rs,*.go,*.py call execute('LspDocumentFormatSync')

  " refer to doc to add more commands
endfunction

augroup lsp_install
  au!
  " call s:on_lsp_buffer_enabled only for languages that has the server registered.
  autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
augroup END
" --- end LSP


" Emmet
let g:user_emmet_install_global = 0
autocmd FileType html,css,eruby EmmetInstall

let g:user_emmet_leader_key='<C-Z>'

let g:user_emmet_settings = {
  \  'eruby': {
  \    'extends': 'html',
  \    'snippets': {
  \      'e': "<% | %>\n${child}<% end %>",
  \      'ee': "<%= | %>"
  \    }
  \  }
  \}


" Markdown syntax
let g:markdown_fenced_languages = ['html', 'python', 'bash=sh', 'ruby', 'vim', 'rust', 'crystal', 'cpp']
let g:markdown_minlines = 100
